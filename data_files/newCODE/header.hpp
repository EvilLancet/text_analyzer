#ifndef HEADER_HPP
#define HEADER_HPP

#include <string>

// Общий заголовок проекта "Поиск определений".
// Здесь объявляются типы данных (TokenT, Token) и прототипы функций,
// которые используются в остальных файлах программы (main.cpp, logic.cpp).
//
// Кратко о том, что делает программа:
// 1. Читает текстовый .txt файл (русский текст в кодировке Windows-1251).
// 2. Разбивает содержимое на токены (слова, знаки препинания и т.п.).
// 3. Для каждого слова проверяет, оканчивается ли оно на один из специальных
//    суффиксов и помечает такие слова как "определения".
// 4. Собирает текст обратно, добавляя символ '±' непосредственно перед каждым
//    помеченным словом.
// 5. Записывает результат в новый файл с суффиксом "_marked".
// 6. Есть два режима запуска:
//    - консольное меню;
//    - GUI-режим через стандартный диалог выбора файла Windows (-gui).

// Тип токена:
// TOK_IDENT        — слово (идентификатор);
// TOK_PUNCTUATION  — знак препинания / одиночный символ;
// TOK_SPACE        — пробельный участок (зарезервировано; сейчас отдельно не используется);
// TOK_EOF          — служебный маркер конца входного потока.
enum TokenT {
    TOK_EOF,
    TOK_IDENT,
    TOK_PUNCTUATION,
    TOK_SPACE
};

// Описание одного токена.
// Токены связаны в двусвязный список.
// type      — тип токена;
// flag      — метка "это определение" (true, если слово оканчивается на один из суффиксов);
// value     — текстовое содержимое токена;
// prev/next — ссылки на соседние токены в списке.
struct Token {
    TokenT type;
    bool   flag;
    char  *value;
    Token *prev;
    Token *next;
};

// Создаёт новый токен указанного типа со значением value.
// Память под копию value внутри токена выделяется динамически.
Token *create_token(TokenT type, const char *value);

// Добавляет токен token в конец двусвязного списка [head..tail].
// Если список пуст, token становится одновременно и head, и tail.
void add_token(Token **head, Token **tail, Token *token);

// Полностью освобождает память всего списка токенов.
void free_tokens(Token *head);

// Проверка: является ли байт русской буквой в кодировке Windows-1251
// (включая символы 'Ё' и 'ё').
// Возвращает ненулевое значение, если да.
int is_russian_letter(int ch);

// Проверка: является ли символ знаком препинания,
// который нужно вынести в отдельный токен.
int is_punctuation(int ch);

// Пропускает подряд идущие пробельные символы во входном тексте.
// Используется лексером.
void skip_whitespace();

// Считывает "слово" (идентификатор):
// русские/латинские буквы, символ подчёркивания '_' и дефис '-'.
// Возвращает новую C-строку (char*), которую потом надо освободить вручную.
char *read_identifier();

// Считывает знак препинания / одиночный символ.
// Поддерживает многоточие '...' как единый токен.
// Возвращает новую C-строку (char*), которую потом надо освободить вручную.
char *read_punctuation();

// Лексер: разбирает входную строку input и строит двусвязный список токенов.
// В конец списка добавляется служебный токен с типом TOK_EOF.
Token *lex(const char *input);

// Обходит список токенов и помечает слова (token->flag = true),
// которые оканчиваются на один из "суффиксов-определений".
void mark_tokens_with_endings(Token *head);

// Читает целиком файл filename (в двоичном режиме) в строку outContent.
// Возвращает true при успехе и false, если файл не удалось открыть.
bool readTextFromFile(const std::string &filename, std::string &outContent);

// Собирает итоговый текст.
// Алгоритм:
// - берём исходную строку originalText посимвольно;
// - если очередное слово помечено как "определение", перед ним вставляется символ '±';
// - все остальные символы (пробелы, переводы строки, знаки препинания и т.д.)
//   остаются как есть.
// Возвращает новый текст.
std::string assembleTextFromTokens(Token *head, const std::string &originalText);

// Записывает строку text в файл outputFilename (в двоичном режиме).
// Возвращает true при успешной записи и false при ошибке.
bool writeProcessedTextToFile(const std::string &outputFilename, const std::string &text);

// Запускает простой GUI-режим под Windows.
// Открывает стандартный диалог выбора файла, затем выполняет полный цикл:
// чтение → анализ → разметка → запись результата.
// По завершении показывает MessageBox с информацией об успешной записи файла.
// Используется, если программа запущена с аргументом -gui.
void runGUI();

#endif // HEADER_HPP
