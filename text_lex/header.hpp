#ifndef HEADER_HPP
#define HEADER_HPP

#include <string>

// Общий заголовок проекта "Поиск определений".
// Здесь объявляются типы данных (TokenT, Token) и прототипы функций,
// используемые в остальных файлах программы (main.cpp, logic.cpp).
//
// Кратко о работе программы:
// 1. Читает текстовый .txt файл (русский текст в кодировке Windows-1251).
// 2. Разбивает содержимое на токены (слова, знаки препинания и т.п.).
// 3. Для каждого слова проверяет, оканчивается ли оно на один из специальных суффиксов и помечает такое слово как "определение".
// 4. Собирает текст обратно, добавляя символ '±' перед каждым помеченным словом.
// 5. Записывает результат в новый файл с суффиксом "_marked".
// 6. Режим запуска: консольное меню.
//
// Тип токена:
// TOK_IDENT        — слово (идентификатор);
// TOK_PUNCTUATION  — знак препинания / одиночный символ;
// TOK_SPACE        — пробельный символ (не используется отдельно);
// TOK_EOF          — служебный маркер конца входного потока.
enum TokenT {
    TOK_EOF,
    TOK_IDENT,
    TOK_PUNCTUATION,
    TOK_SPACE
};

// Описание одного токена.
// Токены связаны в двусвязный список.
// type      — тип токена;
// flag      — метка "определение" (true, если слово оканчивается на один из суффиксов);
// value     — текстовое содержимое токена;
// prev/next — указатели на предыдущий и следующий токены в списке.
struct Token {
    TokenT type;
    bool   flag;
    char  *value;
    Token *prev;
    Token *next;
};

// Создает новый токен указанного типа. Динамически выделяет память под копию value.
Token *create_token(TokenT type, const char *value);

// Добавляет токен token в конец двусвязного списка [head..tail].
// Если список пуст, token становится и head, и tail.
void add_token(Token **head, Token **tail, Token *token);

// Освобождает память всего списка токенов.
void free_tokens(Token *head);

// Проверяет, является ли байт русской буквой (Windows-1251, включая 'Ё' и 'ё').
// Возвращает ненулевое значение, если да.
int is_russian_letter(int ch);

// Проверяет, является ли символ знаком препинания, который должен быть выделен в отдельный токен.
int is_punctuation(int ch);

// Пропускает подряд идущие пробельные символы во входном тексте (используется лексером).
void skip_whitespace();

// Считывает слово (идентификатор) из входной строки (буквы, '_' или '-').
char *read_identifier();

// Считывает символ пунктуации (поддерживает '...' как единый токен).
char *read_punctuation();

// Лексер: разбирает входную строку и строит двусвязный список токенов.
// В конец списка добавляется служебный токен TOK_EOF.
Token *lex(const char *input);

// Помечает токены-слова, оканчивающиеся на указанные суффиксы (устанавливает token->flag = true).
void mark_tokens_with_endings(Token *head);

// Читает весь файл filename (двичное чтение) в строку outContent.
// Возвращает true при успехе и false при ошибке открытия файла.
bool readTextFromFile(const std::string &filename, std::string &outContent);

// Собирает текст из списка токенов, вставляя '±' перед каждым помеченным словом.
// Возвращает получившийся текст.
std::string assembleTextFromTokens(Token *head, const std::string &originalText);

// Записывает строку text в файл outputFilename (двичное запись).
// Возвращает true при успешной записи и false при ошибке.
bool writeProcessedTextToFile(const std::string &outputFilename, const std::string &text);

#endif // HEADER_HPP
